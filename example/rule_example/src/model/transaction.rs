// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `transaction.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_1;

#[derive(PartialEq,Clone,Default)]
pub struct TransactionAction {
    // message fields
    pub header: ::std::vec::Vec<u8>,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionAction {
    fn default() -> &'a TransactionAction {
        <TransactionAction as ::protobuf::Message>::default_instance()
    }
}

impl TransactionAction {
    pub fn new() -> TransactionAction {
        ::std::default::Default::default()
    }

    // bytes header = 1;


    pub fn get_header(&self) -> &[u8] {
        &self.header
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::vec::Vec<u8>) {
        self.header = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.header
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.header, ::std::vec::Vec::new())
    }

    // bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransactionAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.header.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.header);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.header.is_empty() {
            os.write_bytes(1, &self.header)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(2, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionAction {
        TransactionAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "header",
                    |m: &TransactionAction| { &m.header },
                    |m: &mut TransactionAction| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &TransactionAction| { &m.payload },
                    |m: &mut TransactionAction| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionAction>(
                    "TransactionAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionAction {
        static mut instance: ::protobuf::lazy::Lazy<TransactionAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionAction,
        };
        unsafe {
            instance.get(TransactionAction::new)
        }
    }
}

impl ::protobuf::Clear for TransactionAction {
    fn clear(&mut self) {
        self.header.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChaincodeActionPayload {
    // message fields
    pub chaincode_proposal_payload: ::std::vec::Vec<u8>,
    pub action: ::protobuf::SingularPtrField<ChaincodeEndorsedAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaincodeActionPayload {
    fn default() -> &'a ChaincodeActionPayload {
        <ChaincodeActionPayload as ::protobuf::Message>::default_instance()
    }
}

impl ChaincodeActionPayload {
    pub fn new() -> ChaincodeActionPayload {
        ::std::default::Default::default()
    }

    // bytes chaincode_proposal_payload = 1;


    pub fn get_chaincode_proposal_payload(&self) -> &[u8] {
        &self.chaincode_proposal_payload
    }
    pub fn clear_chaincode_proposal_payload(&mut self) {
        self.chaincode_proposal_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_chaincode_proposal_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.chaincode_proposal_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chaincode_proposal_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chaincode_proposal_payload
    }

    // Take field
    pub fn take_chaincode_proposal_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chaincode_proposal_payload, ::std::vec::Vec::new())
    }

    // .ChaincodeEndorsedAction action = 2;


    pub fn get_action(&self) -> &ChaincodeEndorsedAction {
        self.action.as_ref().unwrap_or_else(|| ChaincodeEndorsedAction::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ChaincodeEndorsedAction) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ChaincodeEndorsedAction {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ChaincodeEndorsedAction {
        self.action.take().unwrap_or_else(|| ChaincodeEndorsedAction::new())
    }
}

impl ::protobuf::Message for ChaincodeActionPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chaincode_proposal_payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chaincode_proposal_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.chaincode_proposal_payload);
        }
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.chaincode_proposal_payload.is_empty() {
            os.write_bytes(1, &self.chaincode_proposal_payload)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaincodeActionPayload {
        ChaincodeActionPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "chaincode_proposal_payload",
                    |m: &ChaincodeActionPayload| { &m.chaincode_proposal_payload },
                    |m: &mut ChaincodeActionPayload| { &mut m.chaincode_proposal_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChaincodeEndorsedAction>>(
                    "action",
                    |m: &ChaincodeActionPayload| { &m.action },
                    |m: &mut ChaincodeActionPayload| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaincodeActionPayload>(
                    "ChaincodeActionPayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChaincodeActionPayload {
        static mut instance: ::protobuf::lazy::Lazy<ChaincodeActionPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChaincodeActionPayload,
        };
        unsafe {
            instance.get(ChaincodeActionPayload::new)
        }
    }
}

impl ::protobuf::Clear for ChaincodeActionPayload {
    fn clear(&mut self) {
        self.chaincode_proposal_payload.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaincodeActionPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaincodeActionPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChaincodeEndorsedAction {
    // message fields
    pub proposal_response_payload: ::std::vec::Vec<u8>,
    pub endorsements: ::protobuf::RepeatedField<Endorsement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaincodeEndorsedAction {
    fn default() -> &'a ChaincodeEndorsedAction {
        <ChaincodeEndorsedAction as ::protobuf::Message>::default_instance()
    }
}

impl ChaincodeEndorsedAction {
    pub fn new() -> ChaincodeEndorsedAction {
        ::std::default::Default::default()
    }

    // bytes proposal_response_payload = 1;


    pub fn get_proposal_response_payload(&self) -> &[u8] {
        &self.proposal_response_payload
    }
    pub fn clear_proposal_response_payload(&mut self) {
        self.proposal_response_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposal_response_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposal_response_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal_response_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposal_response_payload
    }

    // Take field
    pub fn take_proposal_response_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposal_response_payload, ::std::vec::Vec::new())
    }

    // repeated .Endorsement endorsements = 2;


    pub fn get_endorsements(&self) -> &[Endorsement] {
        &self.endorsements
    }
    pub fn clear_endorsements(&mut self) {
        self.endorsements.clear();
    }

    // Param is passed by value, moved
    pub fn set_endorsements(&mut self, v: ::protobuf::RepeatedField<Endorsement>) {
        self.endorsements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endorsements(&mut self) -> &mut ::protobuf::RepeatedField<Endorsement> {
        &mut self.endorsements
    }

    // Take field
    pub fn take_endorsements(&mut self) -> ::protobuf::RepeatedField<Endorsement> {
        ::std::mem::replace(&mut self.endorsements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChaincodeEndorsedAction {
    fn is_initialized(&self) -> bool {
        for v in &self.endorsements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposal_response_payload)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endorsements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.proposal_response_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.proposal_response_payload);
        }
        for value in &self.endorsements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.proposal_response_payload.is_empty() {
            os.write_bytes(1, &self.proposal_response_payload)?;
        }
        for v in &self.endorsements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaincodeEndorsedAction {
        ChaincodeEndorsedAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "proposal_response_payload",
                    |m: &ChaincodeEndorsedAction| { &m.proposal_response_payload },
                    |m: &mut ChaincodeEndorsedAction| { &mut m.proposal_response_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Endorsement>>(
                    "endorsements",
                    |m: &ChaincodeEndorsedAction| { &m.endorsements },
                    |m: &mut ChaincodeEndorsedAction| { &mut m.endorsements },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaincodeEndorsedAction>(
                    "ChaincodeEndorsedAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChaincodeEndorsedAction {
        static mut instance: ::protobuf::lazy::Lazy<ChaincodeEndorsedAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChaincodeEndorsedAction,
        };
        unsafe {
            instance.get(ChaincodeEndorsedAction::new)
        }
    }
}

impl ::protobuf::Clear for ChaincodeEndorsedAction {
    fn clear(&mut self) {
        self.proposal_response_payload.clear();
        self.endorsements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaincodeEndorsedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaincodeEndorsedAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Endorsement {
    // message fields
    pub endorser: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Endorsement {
    fn default() -> &'a Endorsement {
        <Endorsement as ::protobuf::Message>::default_instance()
    }
}

impl Endorsement {
    pub fn new() -> Endorsement {
        ::std::default::Default::default()
    }

    // bytes endorser = 1;


    pub fn get_endorser(&self) -> &[u8] {
        &self.endorser
    }
    pub fn clear_endorser(&mut self) {
        self.endorser.clear();
    }

    // Param is passed by value, moved
    pub fn set_endorser(&mut self, v: ::std::vec::Vec<u8>) {
        self.endorser = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endorser(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.endorser
    }

    // Take field
    pub fn take_endorser(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.endorser, ::std::vec::Vec::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Endorsement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.endorser)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.endorser.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.endorser);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.endorser.is_empty() {
            os.write_bytes(1, &self.endorser)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Endorsement {
        Endorsement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "endorser",
                    |m: &Endorsement| { &m.endorser },
                    |m: &mut Endorsement| { &mut m.endorser },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &Endorsement| { &m.signature },
                    |m: &mut Endorsement| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Endorsement>(
                    "Endorsement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Endorsement {
        static mut instance: ::protobuf::lazy::Lazy<Endorsement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Endorsement,
        };
        unsafe {
            instance.get(Endorsement::new)
        }
    }
}

impl ::protobuf::Clear for Endorsement {
    fn clear(&mut self) {
        self.endorser.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Endorsement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Endorsement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposalResponsePayload {
    // message fields
    pub proposal_hash: ::std::vec::Vec<u8>,
    pub extension: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalResponsePayload {
    fn default() -> &'a ProposalResponsePayload {
        <ProposalResponsePayload as ::protobuf::Message>::default_instance()
    }
}

impl ProposalResponsePayload {
    pub fn new() -> ProposalResponsePayload {
        ::std::default::Default::default()
    }

    // bytes proposal_hash = 1;


    pub fn get_proposal_hash(&self) -> &[u8] {
        &self.proposal_hash
    }
    pub fn clear_proposal_hash(&mut self) {
        self.proposal_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposal_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposal_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposal_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposal_hash
    }

    // Take field
    pub fn take_proposal_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposal_hash, ::std::vec::Vec::new())
    }

    // bytes extension = 2;


    pub fn get_extension(&self) -> &[u8] {
        &self.extension
    }
    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::std::vec::Vec<u8>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extension(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extension, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ProposalResponsePayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposal_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.proposal_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.proposal_hash);
        }
        if !self.extension.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.extension);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.proposal_hash.is_empty() {
            os.write_bytes(1, &self.proposal_hash)?;
        }
        if !self.extension.is_empty() {
            os.write_bytes(2, &self.extension)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalResponsePayload {
        ProposalResponsePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "proposal_hash",
                    |m: &ProposalResponsePayload| { &m.proposal_hash },
                    |m: &mut ProposalResponsePayload| { &mut m.proposal_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extension",
                    |m: &ProposalResponsePayload| { &m.extension },
                    |m: &mut ProposalResponsePayload| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProposalResponsePayload>(
                    "ProposalResponsePayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProposalResponsePayload {
        static mut instance: ::protobuf::lazy::Lazy<ProposalResponsePayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProposalResponsePayload,
        };
        unsafe {
            instance.get(ProposalResponsePayload::new)
        }
    }
}

impl ::protobuf::Clear for ProposalResponsePayload {
    fn clear(&mut self) {
        self.proposal_hash.clear();
        self.extension.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalResponsePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalResponsePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChaincodeAction {
    // message fields
    pub results: ::std::vec::Vec<u8>,
    pub events: ::std::vec::Vec<u8>,
    pub response: ::protobuf::SingularPtrField<Response>,
    pub chaincode_id: ::protobuf::SingularPtrField<ChaincodeID>,
    pub token_expectation: ::protobuf::SingularPtrField<TokenExpectation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaincodeAction {
    fn default() -> &'a ChaincodeAction {
        <ChaincodeAction as ::protobuf::Message>::default_instance()
    }
}

impl ChaincodeAction {
    pub fn new() -> ChaincodeAction {
        ::std::default::Default::default()
    }

    // bytes results = 1;


    pub fn get_results(&self) -> &[u8] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<u8>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    // bytes events = 2;


    pub fn get_events(&self) -> &[u8] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::std::vec::Vec<u8>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_events(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.events, ::std::vec::Vec::new())
    }

    // .Response response = 3;


    pub fn get_response(&self) -> &Response {
        self.response.as_ref().unwrap_or_else(|| Response::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: Response) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut Response {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> Response {
        self.response.take().unwrap_or_else(|| Response::new())
    }

    // .ChaincodeID chaincode_id = 4;


    pub fn get_chaincode_id(&self) -> &ChaincodeID {
        self.chaincode_id.as_ref().unwrap_or_else(|| ChaincodeID::default_instance())
    }
    pub fn clear_chaincode_id(&mut self) {
        self.chaincode_id.clear();
    }

    pub fn has_chaincode_id(&self) -> bool {
        self.chaincode_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chaincode_id(&mut self, v: ChaincodeID) {
        self.chaincode_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chaincode_id(&mut self) -> &mut ChaincodeID {
        if self.chaincode_id.is_none() {
            self.chaincode_id.set_default();
        }
        self.chaincode_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chaincode_id(&mut self) -> ChaincodeID {
        self.chaincode_id.take().unwrap_or_else(|| ChaincodeID::new())
    }

    // .TokenExpectation token_expectation = 5;


    pub fn get_token_expectation(&self) -> &TokenExpectation {
        self.token_expectation.as_ref().unwrap_or_else(|| TokenExpectation::default_instance())
    }
    pub fn clear_token_expectation(&mut self) {
        self.token_expectation.clear();
    }

    pub fn has_token_expectation(&self) -> bool {
        self.token_expectation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_expectation(&mut self, v: TokenExpectation) {
        self.token_expectation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_expectation(&mut self) -> &mut TokenExpectation {
        if self.token_expectation.is_none() {
            self.token_expectation.set_default();
        }
        self.token_expectation.as_mut().unwrap()
    }

    // Take field
    pub fn take_token_expectation(&mut self) -> TokenExpectation {
        self.token_expectation.take().unwrap_or_else(|| TokenExpectation::new())
    }
}

impl ::protobuf::Message for ChaincodeAction {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chaincode_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.token_expectation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.events)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chaincode_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.token_expectation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.results.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.results);
        }
        if !self.events.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.events);
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.chaincode_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.token_expectation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.results.is_empty() {
            os.write_bytes(1, &self.results)?;
        }
        if !self.events.is_empty() {
            os.write_bytes(2, &self.events)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.chaincode_id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.token_expectation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaincodeAction {
        ChaincodeAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "results",
                    |m: &ChaincodeAction| { &m.results },
                    |m: &mut ChaincodeAction| { &mut m.results },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "events",
                    |m: &ChaincodeAction| { &m.events },
                    |m: &mut ChaincodeAction| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response>>(
                    "response",
                    |m: &ChaincodeAction| { &m.response },
                    |m: &mut ChaincodeAction| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChaincodeID>>(
                    "chaincode_id",
                    |m: &ChaincodeAction| { &m.chaincode_id },
                    |m: &mut ChaincodeAction| { &mut m.chaincode_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TokenExpectation>>(
                    "token_expectation",
                    |m: &ChaincodeAction| { &m.token_expectation },
                    |m: &mut ChaincodeAction| { &mut m.token_expectation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaincodeAction>(
                    "ChaincodeAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChaincodeAction {
        static mut instance: ::protobuf::lazy::Lazy<ChaincodeAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChaincodeAction,
        };
        unsafe {
            instance.get(ChaincodeAction::new)
        }
    }
}

impl ::protobuf::Clear for ChaincodeAction {
    fn clear(&mut self) {
        self.results.clear();
        self.events.clear();
        self.response.clear();
        self.chaincode_id.clear();
        self.token_expectation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaincodeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaincodeAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub status: i32,
    pub message: ::std::string::String,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &Response| { &m.status },
                    |m: &mut Response| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &Response| { &m.message },
                    |m: &mut Response| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &Response| { &m.payload },
                    |m: &mut Response| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.status = 0;
        self.message.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChaincodeID {
    // message fields
    pub path: ::std::string::String,
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaincodeID {
    fn default() -> &'a ChaincodeID {
        <ChaincodeID as ::protobuf::Message>::default_instance()
    }
}

impl ChaincodeID {
    pub fn new() -> ChaincodeID {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 3;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChaincodeID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(3, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaincodeID {
        ChaincodeID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &ChaincodeID| { &m.path },
                    |m: &mut ChaincodeID| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ChaincodeID| { &m.name },
                    |m: &mut ChaincodeID| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &ChaincodeID| { &m.version },
                    |m: &mut ChaincodeID| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaincodeID>(
                    "ChaincodeID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChaincodeID {
        static mut instance: ::protobuf::lazy::Lazy<ChaincodeID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChaincodeID,
        };
        unsafe {
            instance.get(ChaincodeID::new)
        }
    }
}

impl ::protobuf::Clear for ChaincodeID {
    fn clear(&mut self) {
        self.path.clear();
        self.name.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaincodeID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaincodeID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TokenExpectation {
    // message oneof groups
    pub Expectation: ::std::option::Option<TokenExpectation_oneof_Expectation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenExpectation {
    fn default() -> &'a TokenExpectation {
        <TokenExpectation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TokenExpectation_oneof_Expectation {
    plain_expectation(PlainExpectation),
}

impl TokenExpectation {
    pub fn new() -> TokenExpectation {
        ::std::default::Default::default()
    }

    // .PlainExpectation plain_expectation = 1;


    pub fn get_plain_expectation(&self) -> &PlainExpectation {
        match self.Expectation {
            ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(ref v)) => v,
            _ => PlainExpectation::default_instance(),
        }
    }
    pub fn clear_plain_expectation(&mut self) {
        self.Expectation = ::std::option::Option::None;
    }

    pub fn has_plain_expectation(&self) -> bool {
        match self.Expectation {
            ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plain_expectation(&mut self, v: PlainExpectation) {
        self.Expectation = ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plain_expectation(&mut self) -> &mut PlainExpectation {
        if let ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(_)) = self.Expectation {
        } else {
            self.Expectation = ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(PlainExpectation::new()));
        }
        match self.Expectation {
            ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plain_expectation(&mut self) -> PlainExpectation {
        if self.has_plain_expectation() {
            match self.Expectation.take() {
                ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(v)) => v,
                _ => panic!(),
            }
        } else {
            PlainExpectation::new()
        }
    }
}

impl ::protobuf::Message for TokenExpectation {
    fn is_initialized(&self) -> bool {
        if let Some(TokenExpectation_oneof_Expectation::plain_expectation(ref v)) = self.Expectation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Expectation = ::std::option::Option::Some(TokenExpectation_oneof_Expectation::plain_expectation(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Expectation {
            match v {
                &TokenExpectation_oneof_Expectation::plain_expectation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Expectation {
            match v {
                &TokenExpectation_oneof_Expectation::plain_expectation(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenExpectation {
        TokenExpectation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlainExpectation>(
                    "plain_expectation",
                    TokenExpectation::has_plain_expectation,
                    TokenExpectation::get_plain_expectation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TokenExpectation>(
                    "TokenExpectation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TokenExpectation {
        static mut instance: ::protobuf::lazy::Lazy<TokenExpectation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TokenExpectation,
        };
        unsafe {
            instance.get(TokenExpectation::new)
        }
    }
}

impl ::protobuf::Clear for TokenExpectation {
    fn clear(&mut self) {
        self.Expectation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokenExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenExpectation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlainExpectation {
    // message oneof groups
    pub payload: ::std::option::Option<PlainExpectation_oneof_payload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlainExpectation {
    fn default() -> &'a PlainExpectation {
        <PlainExpectation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PlainExpectation_oneof_payload {
    import_expectation(PlainTokenExpectation),
    transfer_expectation(PlainTokenExpectation),
}

impl PlainExpectation {
    pub fn new() -> PlainExpectation {
        ::std::default::Default::default()
    }

    // .PlainTokenExpectation import_expectation = 1;


    pub fn get_import_expectation(&self) -> &PlainTokenExpectation {
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(ref v)) => v,
            _ => PlainTokenExpectation::default_instance(),
        }
    }
    pub fn clear_import_expectation(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_import_expectation(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_import_expectation(&mut self, v: PlainTokenExpectation) {
        self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_import_expectation(&mut self) -> &mut PlainTokenExpectation {
        if let ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(PlainTokenExpectation::new()));
        }
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_import_expectation(&mut self) -> PlainTokenExpectation {
        if self.has_import_expectation() {
            match self.payload.take() {
                ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(v)) => v,
                _ => panic!(),
            }
        } else {
            PlainTokenExpectation::new()
        }
    }

    // .PlainTokenExpectation transfer_expectation = 2;


    pub fn get_transfer_expectation(&self) -> &PlainTokenExpectation {
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(ref v)) => v,
            _ => PlainTokenExpectation::default_instance(),
        }
    }
    pub fn clear_transfer_expectation(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_transfer_expectation(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transfer_expectation(&mut self, v: PlainTokenExpectation) {
        self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transfer_expectation(&mut self) -> &mut PlainTokenExpectation {
        if let ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(PlainTokenExpectation::new()));
        }
        match self.payload {
            ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transfer_expectation(&mut self) -> PlainTokenExpectation {
        if self.has_transfer_expectation() {
            match self.payload.take() {
                ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(v)) => v,
                _ => panic!(),
            }
        } else {
            PlainTokenExpectation::new()
        }
    }
}

impl ::protobuf::Message for PlainExpectation {
    fn is_initialized(&self) -> bool {
        if let Some(PlainExpectation_oneof_payload::import_expectation(ref v)) = self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(PlainExpectation_oneof_payload::transfer_expectation(ref v)) = self.payload {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::import_expectation(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(PlainExpectation_oneof_payload::transfer_expectation(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &PlainExpectation_oneof_payload::import_expectation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PlainExpectation_oneof_payload::transfer_expectation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &PlainExpectation_oneof_payload::import_expectation(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PlainExpectation_oneof_payload::transfer_expectation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlainExpectation {
        PlainExpectation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlainTokenExpectation>(
                    "import_expectation",
                    PlainExpectation::has_import_expectation,
                    PlainExpectation::get_import_expectation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlainTokenExpectation>(
                    "transfer_expectation",
                    PlainExpectation::has_transfer_expectation,
                    PlainExpectation::get_transfer_expectation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlainExpectation>(
                    "PlainExpectation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlainExpectation {
        static mut instance: ::protobuf::lazy::Lazy<PlainExpectation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlainExpectation,
        };
        unsafe {
            instance.get(PlainExpectation::new)
        }
    }
}

impl ::protobuf::Clear for PlainExpectation {
    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlainExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlainExpectation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlainTokenExpectation {
    // message fields
    pub outputs: ::protobuf::RepeatedField<PlainOutput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlainTokenExpectation {
    fn default() -> &'a PlainTokenExpectation {
        <PlainTokenExpectation as ::protobuf::Message>::default_instance()
    }
}

impl PlainTokenExpectation {
    pub fn new() -> PlainTokenExpectation {
        ::std::default::Default::default()
    }

    // repeated .PlainOutput outputs = 1;


    pub fn get_outputs(&self) -> &[PlainOutput] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<PlainOutput>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<PlainOutput> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<PlainOutput> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlainTokenExpectation {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlainTokenExpectation {
        PlainTokenExpectation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlainOutput>>(
                    "outputs",
                    |m: &PlainTokenExpectation| { &m.outputs },
                    |m: &mut PlainTokenExpectation| { &mut m.outputs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlainTokenExpectation>(
                    "PlainTokenExpectation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlainTokenExpectation {
        static mut instance: ::protobuf::lazy::Lazy<PlainTokenExpectation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlainTokenExpectation,
        };
        unsafe {
            instance.get(PlainTokenExpectation::new)
        }
    }
}

impl ::protobuf::Clear for PlainTokenExpectation {
    fn clear(&mut self) {
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlainTokenExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlainTokenExpectation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlainOutput {
    // message fields
    pub owner: ::std::vec::Vec<u8>,
    pub field_type: ::std::string::String,
    pub quantity: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlainOutput {
    fn default() -> &'a PlainOutput {
        <PlainOutput as ::protobuf::Message>::default_instance()
    }
}

impl PlainOutput {
    pub fn new() -> PlainOutput {
        ::std::default::Default::default()
    }

    // bytes owner = 1;


    pub fn get_owner(&self) -> &[u8] {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner, ::std::vec::Vec::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // uint64 quantity = 3;


    pub fn get_quantity(&self) -> u64 {
        self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = 0;
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u64) {
        self.quantity = v;
    }
}

impl ::protobuf::Message for PlainOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quantity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if self.quantity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.quantity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner.is_empty() {
            os.write_bytes(1, &self.owner)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if self.quantity != 0 {
            os.write_uint64(3, self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlainOutput {
        PlainOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "owner",
                    |m: &PlainOutput| { &m.owner },
                    |m: &mut PlainOutput| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &PlainOutput| { &m.field_type },
                    |m: &mut PlainOutput| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quantity",
                    |m: &PlainOutput| { &m.quantity },
                    |m: &mut PlainOutput| { &mut m.quantity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlainOutput>(
                    "PlainOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlainOutput {
        static mut instance: ::protobuf::lazy::Lazy<PlainOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlainOutput,
        };
        unsafe {
            instance.get(PlainOutput::new)
        }
    }
}

impl ::protobuf::Clear for PlainOutput {
    fn clear(&mut self) {
        self.owner.clear();
        self.field_type.clear();
        self.quantity = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlainOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlainOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChaincodeEvent {
    // message fields
    pub chaincode_id: ::std::string::String,
    pub tx_id: ::std::string::String,
    pub event_name: ::std::string::String,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChaincodeEvent {
    fn default() -> &'a ChaincodeEvent {
        <ChaincodeEvent as ::protobuf::Message>::default_instance()
    }
}

impl ChaincodeEvent {
    pub fn new() -> ChaincodeEvent {
        ::std::default::Default::default()
    }

    // string chaincode_id = 1;


    pub fn get_chaincode_id(&self) -> &str {
        &self.chaincode_id
    }
    pub fn clear_chaincode_id(&mut self) {
        self.chaincode_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_chaincode_id(&mut self, v: ::std::string::String) {
        self.chaincode_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chaincode_id(&mut self) -> &mut ::std::string::String {
        &mut self.chaincode_id
    }

    // Take field
    pub fn take_chaincode_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chaincode_id, ::std::string::String::new())
    }

    // string tx_id = 2;


    pub fn get_tx_id(&self) -> &str {
        &self.tx_id
    }
    pub fn clear_tx_id(&mut self) {
        self.tx_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_id(&mut self, v: ::std::string::String) {
        self.tx_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_id(&mut self) -> &mut ::std::string::String {
        &mut self.tx_id
    }

    // Take field
    pub fn take_tx_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_id, ::std::string::String::new())
    }

    // string event_name = 3;


    pub fn get_event_name(&self) -> &str {
        &self.event_name
    }
    pub fn clear_event_name(&mut self) {
        self.event_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        &mut self.event_name
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_name, ::std::string::String::new())
    }

    // bytes payload = 4;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChaincodeEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chaincode_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chaincode_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chaincode_id);
        }
        if !self.tx_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_id);
        }
        if !self.event_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.event_name);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.chaincode_id.is_empty() {
            os.write_string(1, &self.chaincode_id)?;
        }
        if !self.tx_id.is_empty() {
            os.write_string(2, &self.tx_id)?;
        }
        if !self.event_name.is_empty() {
            os.write_string(3, &self.event_name)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(4, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChaincodeEvent {
        ChaincodeEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chaincode_id",
                    |m: &ChaincodeEvent| { &m.chaincode_id },
                    |m: &mut ChaincodeEvent| { &mut m.chaincode_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_id",
                    |m: &ChaincodeEvent| { &m.tx_id },
                    |m: &mut ChaincodeEvent| { &mut m.tx_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_name",
                    |m: &ChaincodeEvent| { &m.event_name },
                    |m: &mut ChaincodeEvent| { &mut m.event_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &ChaincodeEvent| { &m.payload },
                    |m: &mut ChaincodeEvent| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChaincodeEvent>(
                    "ChaincodeEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChaincodeEvent {
        static mut instance: ::protobuf::lazy::Lazy<ChaincodeEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChaincodeEvent,
        };
        unsafe {
            instance.get(ChaincodeEvent::new)
        }
    }
}

impl ::protobuf::Clear for ChaincodeEvent {
    fn clear(&mut self) {
        self.chaincode_id.clear();
        self.tx_id.clear();
        self.event_name.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChaincodeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChaincodeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SerializedIdentity {
    // message fields
    pub mspid: ::std::string::String,
    pub id_bytes: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SerializedIdentity {
    fn default() -> &'a SerializedIdentity {
        <SerializedIdentity as ::protobuf::Message>::default_instance()
    }
}

impl SerializedIdentity {
    pub fn new() -> SerializedIdentity {
        ::std::default::Default::default()
    }

    // string mspid = 1;


    pub fn get_mspid(&self) -> &str {
        &self.mspid
    }
    pub fn clear_mspid(&mut self) {
        self.mspid.clear();
    }

    // Param is passed by value, moved
    pub fn set_mspid(&mut self, v: ::std::string::String) {
        self.mspid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mspid(&mut self) -> &mut ::std::string::String {
        &mut self.mspid
    }

    // Take field
    pub fn take_mspid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mspid, ::std::string::String::new())
    }

    // bytes id_bytes = 2;


    pub fn get_id_bytes(&self) -> &[u8] {
        &self.id_bytes
    }
    pub fn clear_id_bytes(&mut self) {
        self.id_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.id_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id_bytes
    }

    // Take field
    pub fn take_id_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id_bytes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SerializedIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mspid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mspid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mspid);
        }
        if !self.id_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.id_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mspid.is_empty() {
            os.write_string(1, &self.mspid)?;
        }
        if !self.id_bytes.is_empty() {
            os.write_bytes(2, &self.id_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SerializedIdentity {
        SerializedIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mspid",
                    |m: &SerializedIdentity| { &m.mspid },
                    |m: &mut SerializedIdentity| { &mut m.mspid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id_bytes",
                    |m: &SerializedIdentity| { &m.id_bytes },
                    |m: &mut SerializedIdentity| { &mut m.id_bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SerializedIdentity>(
                    "SerializedIdentity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SerializedIdentity {
        static mut instance: ::protobuf::lazy::Lazy<SerializedIdentity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SerializedIdentity,
        };
        unsafe {
            instance.get(SerializedIdentity::new)
        }
    }
}

impl ::protobuf::Clear for SerializedIdentity {
    fn clear(&mut self) {
        self.mspid.clear();
        self.id_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SerializedIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SerializedIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11transaction.proto\"E\n\x11TransactionAction\x12\x16\n\x06header\
    \x18\x01\x20\x01(\x0cR\x06header\x12\x18\n\x07payload\x18\x02\x20\x01(\
    \x0cR\x07payload\"\x88\x01\n\x16ChaincodeActionPayload\x12<\n\x1achainco\
    de_proposal_payload\x18\x01\x20\x01(\x0cR\x18chaincodeProposalPayload\
    \x120\n\x06action\x18\x02\x20\x01(\x0b2\x18.ChaincodeEndorsedActionR\x06\
    action\"\x87\x01\n\x17ChaincodeEndorsedAction\x12:\n\x19proposal_respons\
    e_payload\x18\x01\x20\x01(\x0cR\x17proposalResponsePayload\x120\n\x0cend\
    orsements\x18\x02\x20\x03(\x0b2\x0c.EndorsementR\x0cendorsements\"G\n\
    \x0bEndorsement\x12\x1a\n\x08endorser\x18\x01\x20\x01(\x0cR\x08endorser\
    \x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\"\\\n\x17Proposal\
    ResponsePayload\x12#\n\rproposal_hash\x18\x01\x20\x01(\x0cR\x0cproposalH\
    ash\x12\x1c\n\textension\x18\x02\x20\x01(\x0cR\textension\"\xdb\x01\n\
    \x0fChaincodeAction\x12\x18\n\x07results\x18\x01\x20\x01(\x0cR\x07result\
    s\x12\x16\n\x06events\x18\x02\x20\x01(\x0cR\x06events\x12%\n\x08response\
    \x18\x03\x20\x01(\x0b2\t.ResponseR\x08response\x12/\n\x0cchaincode_id\
    \x18\x04\x20\x01(\x0b2\x0c.ChaincodeIDR\x0bchaincodeId\x12>\n\x11token_e\
    xpectation\x18\x05\x20\x01(\x0b2\x11.TokenExpectationR\x10tokenExpectati\
    on\"V\n\x08Response\x12\x16\n\x06status\x18\x01\x20\x01(\x05R\x06status\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x18\n\x07payloa\
    d\x18\x03\x20\x01(\x0cR\x07payload\"O\n\x0bChaincodeID\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04na\
    me\x12\x18\n\x07version\x18\x03\x20\x01(\tR\x07version\"c\n\x10TokenExpe\
    ctation\x12@\n\x11plain_expectation\x18\x01\x20\x01(\x0b2\x11.PlainExpec\
    tationH\0R\x10plainExpectationB\r\n\x0bExpectation\"\xb3\x01\n\x10PlainE\
    xpectation\x12G\n\x12import_expectation\x18\x01\x20\x01(\x0b2\x16.PlainT\
    okenExpectationH\0R\x11importExpectation\x12K\n\x14transfer_expectation\
    \x18\x02\x20\x01(\x0b2\x16.PlainTokenExpectationH\0R\x13transferExpectat\
    ionB\t\n\x07payload\"?\n\x15PlainTokenExpectation\x12&\n\x07outputs\x18\
    \x01\x20\x03(\x0b2\x0c.PlainOutputR\x07outputs\"S\n\x0bPlainOutput\x12\
    \x14\n\x05owner\x18\x01\x20\x01(\x0cR\x05owner\x12\x12\n\x04type\x18\x02\
    \x20\x01(\tR\x04type\x12\x1a\n\x08quantity\x18\x03\x20\x01(\x04R\x08quan\
    tity\"\x81\x01\n\x0eChaincodeEvent\x12!\n\x0cchaincode_id\x18\x01\x20\
    \x01(\tR\x0bchaincodeId\x12\x13\n\x05tx_id\x18\x02\x20\x01(\tR\x04txId\
    \x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12\x18\n\x07paylo\
    ad\x18\x04\x20\x01(\x0cR\x07payload\"E\n\x12SerializedIdentity\x12\x14\n\
    \x05mspid\x18\x01\x20\x01(\tR\x05mspid\x12\x19\n\x08id_bytes\x18\x02\x20\
    \x01(\x0cR\x07idBytesJ\x87M\n\x07\x12\x05\0\0\xd7\x01\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x98\x01\n\x02\x04\0\x12\x04\x04\0\x0c\x01\x1a\x8b\
    \x01\x20TransactionAction\x20binds\x20a\x20proposal\x20to\x20its\x20acti\
    on.\x20\x20The\x20type\x20field\x20in\x20the\n\x20header\x20dictates\x20\
    the\x20type\x20of\x20action\x20to\x20be\x20applied\x20to\x20the\x20ledge\
    r.\n\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x19\nN\n\x04\x04\0\x02\0\x12\
    \x03\x07\x08\x19\x1aA\x20The\x20header\x20of\x20the\x20proposal\x20actio\
    n,\x20which\x20is\x20the\x20proposal\x20header\n\n\r\n\x05\x04\0\x02\0\
    \x04\x12\x04\x07\x08\x04\x1b\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x07\x08\
    \r\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x07\x0e\x14\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03\x07\x17\x18\n\x86\x01\n\x04\x04\0\x02\x01\x12\x03\x0b\x08\
    \x1a\x1ay\x20The\x20payload\x20of\x20the\x20action\x20as\x20defined\x20b\
    y\x20the\x20type\x20in\x20the\x20header\x20For\n\x20chaincode,\x20it's\
    \x20the\x20bytes\x20of\x20ChaincodeActionPayload\n\n\r\n\x05\x04\0\x02\
    \x01\x04\x12\x04\x0b\x08\x07\x19\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\
    \x0b\x08\r\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0b\x0e\x15\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\x0b\x18\x19\n\xe9\x01\n\x02\x04\x01\x12\x04\
    \x11\0\x20\x01\x1a\xdc\x01\x20ChaincodeActionPayload\x20is\x20the\x20mes\
    sage\x20to\x20be\x20used\x20for\x20the\x20TransactionAction's\n\x20paylo\
    ad\x20when\x20the\x20Header's\x20type\x20is\x20set\x20to\x20CHAINCODE.\
    \x20\x20It\x20carries\x20the\n\x20chaincodeProposalPayload\x20and\x20an\
    \x20endorsed\x20action\x20to\x20apply\x20to\x20the\x20ledger.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03\x11\x08\x1e\n\x86\x05\n\x04\x04\x01\x02\0\x12\
    \x03\x1c\x08-\x1a\xf8\x04\x20This\x20field\x20contains\x20the\x20bytes\
    \x20of\x20the\x20ChaincodeProposalPayload\x20message\x20from\n\x20the\
    \x20original\x20invocation\x20(essentially\x20the\x20arguments)\x20after\
    \x20the\x20application\n\x20of\x20the\x20visibility\x20function.\x20The\
    \x20main\x20visibility\x20modes\x20are\x20\"full\"\x20(the\n\x20entire\
    \x20ChaincodeProposalPayload\x20message\x20is\x20included\x20here),\x20\
    \"hash\"\x20(only\n\x20the\x20hash\x20of\x20the\x20ChaincodeProposalPayl\
    oad\x20message\x20is\x20included)\x20or\n\x20\"nothing\".\x20\x20This\
    \x20field\x20will\x20be\x20used\x20to\x20check\x20the\x20consistency\x20\
    of\n\x20ProposalResponsePayload.proposalHash.\x20\x20For\x20the\x20CHAIN\
    CODE\x20type,\n\x20ProposalResponsePayload.proposalHash\x20is\x20suppose\
    d\x20to\x20be\x20H(ProposalHeader\x20||\n\x20f(ChaincodeProposalPayload)\
    )\x20where\x20f\x20is\x20the\x20visibility\x20function.\n\n\r\n\x05\x04\
    \x01\x02\0\x04\x12\x04\x1c\x08\x11\x20\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03\x1c\x08\r\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1c\x0e(\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03\x1c+,\n9\n\x04\x04\x01\x02\x01\x12\x03\
    \x1f\x08+\x1a,\x20The\x20list\x20of\x20actions\x20to\x20apply\x20to\x20t\
    he\x20ledger\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x1f\x08\x1c-\n\x0c\
    \n\x05\x04\x01\x02\x01\x06\x12\x03\x1f\x08\x1f\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x03\x1f\x20&\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1f)*\
    \ng\n\x02\x04\x02\x12\x04$\0.\x01\x1a[\x20ChaincodeEndorsedAction\x20car\
    ries\x20information\x20about\x20the\x20endorsement\x20of\x20a\n\x20speci\
    fic\x20proposal\n\n\n\n\x03\x04\x02\x01\x12\x03$\x08\x1f\n\xd1\x01\n\x04\
    \x04\x02\x02\0\x12\x03)\x08,\x1a\xc3\x01\x20This\x20is\x20the\x20bytes\
    \x20of\x20the\x20ProposalResponsePayload\x20message\x20signed\x20by\x20t\
    he\n\x20endorsers.\x20\x20Recall\x20that\x20for\x20the\x20CHAINCODE\x20t\
    ype,\x20the\n\x20ProposalResponsePayload's\x20extenstion\x20field\x20car\
    ries\x20a\x20ChaincodeAction\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x04)\x08$\
    !\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03)\x08\r\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03)\x0e'\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03)*+\np\n\x04\x04\
    \x02\x02\x01\x12\x03-\x08.\x1ac\x20The\x20endorsement\x20of\x20the\x20pr\
    oposal,\x20basically\x20the\x20endorser's\x20signature\x20over\n\x20prop\
    osalResponsePayload\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03-\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03-\x11\x1c\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03-\x1d)\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03-,-\n\xfc\
    \x04\n\x02\x04\x03\x12\x049\0A\x01\x1a\xef\x04\x20An\x20endorsement\x20i\
    s\x20a\x20signature\x20of\x20an\x20endorser\x20over\x20a\x20proposal\x20\
    response.\x20\x20By\n\x20producing\x20an\x20endorsement\x20message,\x20a\
    n\x20endorser\x20implicitly\x20\"approves\"\x20that\n\x20proposal\x20res\
    ponse\x20and\x20the\x20actions\x20contained\x20therein.\x20When\x20enoug\
    h\n\x20endorsements\x20have\x20been\x20collected,\x20a\x20transaction\
    \x20can\x20be\x20generated\x20out\x20of\x20a\n\x20set\x20of\x20proposal\
    \x20responses.\x20\x20Note\x20that\x20this\x20message\x20only\x20contain\
    s\x20an\x20identity\n\x20and\x20a\x20signature\x20but\x20no\x20signed\
    \x20payload.\x20This\x20is\x20intentional\x20because\n\x20endorsements\
    \x20are\x20supposed\x20to\x20be\x20collected\x20in\x20a\x20transaction,\
    \x20and\x20they\x20are\x20all\n\x20expected\x20to\x20endorse\x20a\x20sin\
    gle\x20proposal\x20response/action\x20(many\x20endorsements\n\x20over\
    \x20a\x20single\x20proposal\x20response)\n\n\n\n\x03\x04\x03\x01\x12\x03\
    9\x08\x13\n>\n\x04\x04\x03\x02\0\x12\x03<\x08\x1b\x1a1\x20Identity\x20of\
    \x20the\x20endorser\x20(e.g.\x20its\x20certificate)\n\n\r\n\x05\x04\x03\
    \x02\0\x04\x12\x04<\x089\x15\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03<\x08\
    \r\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03<\x0e\x16\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03<\x19\x1a\n\xa2\x01\n\x04\x04\x03\x02\x01\x12\x03@\x08\
    \x1c\x1a\x94\x01\x20Signature\x20of\x20the\x20payload\x20included\x20in\
    \x20ProposalResponse\x20concatenated\x20with\n\x20the\x20endorser's\x20c\
    ertificate;\x20ie,\x20sign(ProposalResponse.payload\x20+\x20endorser)\n\
    \n\r\n\x05\x04\x03\x02\x01\x04\x12\x04@\x08<\x1b\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03@\x08\r\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03@\x0e\x17\
    \n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03@\x1a\x1b\n\xfd\x02\n\x02\x04\
    \x04\x12\x04H\0a\x01\x1a\xf0\x02\x20ProposalResponsePayload\x20is\x20the\
    \x20payload\x20of\x20a\x20proposal\x20response.\x20\x20This\x20message\n\
    \x20is\x20the\x20\"bridge\"\x20between\x20the\x20client's\x20request\x20\
    and\x20the\x20endorser's\x20action\x20in\n\x20response\x20to\x20that\x20\
    request.\x20Concretely,\x20for\x20chaincodes,\x20it\x20contains\x20a\x20\
    hashed\n\x20representation\x20of\x20the\x20proposal\x20(proposalHash)\
    \x20and\x20a\x20representation\x20of\x20the\n\x20chaincode\x20state\x20c\
    hanges\x20and\x20events\x20inside\x20the\x20extension\x20field.\n\n\n\n\
    \x03\x04\x04\x01\x12\x03H\x08\x1f\n\x85\x08\n\x04\x04\x04\x02\0\x12\x03Y\
    \x08\x20\x1a\xf7\x07\x20Hash\x20of\x20the\x20proposal\x20that\x20trigger\
    ed\x20this\x20response.\x20The\x20hash\x20is\x20used\x20to\n\x20link\x20\
    a\x20response\x20with\x20its\x20proposal,\x20both\x20for\x20bookeeping\
    \x20purposes\x20on\x20an\n\x20asynchronous\x20system\x20and\x20for\x20se\
    curity\x20reasons\x20(accountability,\n\x20non-repudiation).\x20The\x20h\
    ash\x20usually\x20covers\x20the\x20entire\x20Proposal\x20message\n\x20(b\
    yte-by-byte).\x20However\x20this\x20implies\x20that\x20the\x20hash\x20ca\
    n\x20only\x20be\x20verified\n\x20if\x20the\x20entire\x20proposal\x20mess\
    age\x20is\x20available\x20when\x20ProposalResponsePayload\x20is\n\x20inc\
    luded\x20in\x20a\x20transaction\x20or\x20stored\x20in\x20the\x20ledger.\
    \x20For\x20confidentiality\n\x20reasons,\x20with\x20chaincodes\x20it\x20\
    might\x20be\x20undesirable\x20to\x20store\x20the\x20proposal\n\x20payloa\
    d\x20in\x20the\x20ledger.\x20\x20If\x20the\x20type\x20is\x20CHAINCODE,\
    \x20this\x20is\x20handled\x20by\n\x20separating\x20the\x20proposal's\x20\
    header\x20and\n\x20the\x20payload:\x20the\x20header\x20is\x20always\x20h\
    ashed\x20in\x20its\x20entirety\x20whereas\x20the\n\x20payload\x20can\x20\
    either\x20be\x20hashed\x20fully,\x20or\x20only\x20its\x20hash\x20may\x20\
    be\x20hashed,\x20or\n\x20nothing\x20from\x20the\x20payload\x20can\x20be\
    \x20hashed.\x20The\x20PayloadVisibility\x20field\x20in\x20the\n\x20Heade\
    r's\x20extension\x20controls\x20to\x20which\x20extent\x20the\x20proposal\
    \x20payload\x20is\n\x20\"visible\"\x20in\x20the\x20sense\x20that\x20was\
    \x20just\x20explained.\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04Y\x08H!\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03Y\x08\r\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03Y\x0e\x1b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03Y\x1e\x1f\n\
    \xe2\x02\n\x04\x04\x04\x02\x01\x12\x03`\x08\x1c\x1a\xd4\x02\x20Extension\
    \x20should\x20be\x20unmarshaled\x20to\x20a\x20type-specific\x20message.\
    \x20The\x20type\x20of\n\x20the\x20extension\x20in\x20any\x20proposal\x20\
    response\x20depends\x20on\x20the\x20type\x20of\x20the\x20proposal\n\x20t\
    hat\x20the\x20client\x20selected\x20when\x20the\x20proposal\x20was\x20in\
    itially\x20sent\x20out.\x20\x20In\n\x20particular,\x20this\x20informatio\
    n\x20is\x20stored\x20in\x20the\x20type\x20field\x20of\x20a\x20Header.\
    \x20\x20For\n\x20chaincode,\x20it's\x20a\x20ChaincodeAction\x20message\n\
    \n\r\n\x05\x04\x04\x02\x01\x04\x12\x04`\x08Y\x20\n\x0c\n\x05\x04\x04\x02\
    \x01\x05\x12\x03`\x08\r\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03`\x0e\x17\
    \n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03`\x1a\x1b\nk\n\x02\x04\x05\x12\
    \x04e\0|\x01\x1a_\x20ChaincodeAction\x20contains\x20the\x20actions\x20th\
    e\x20events\x20generated\x20by\x20the\x20execution\n\x20of\x20the\x20cha\
    incode.\n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\x17\nw\n\x04\x04\x05\x02\0\
    \x12\x03i\x08\x1a\x1aj\x20This\x20field\x20contains\x20the\x20read\x20se\
    t\x20and\x20the\x20write\x20set\x20produced\x20by\x20the\n\x20chaincode\
    \x20executing\x20this\x20invocation.\n\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04i\x08e\x19\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03i\x08\r\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03i\x0e\x15\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03i\x18\x19\nd\n\x04\x04\x05\x02\x01\x12\x03m\x08\x19\x1aW\x20This\x20\
    field\x20contains\x20the\x20events\x20generated\x20by\x20the\x20chaincod\
    e\x20executing\x20this\n\x20invocation.\n\n\r\n\x05\x04\x05\x02\x01\x04\
    \x12\x04m\x08i\x1a\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03m\x08\r\n\x0c\
    \n\x05\x04\x05\x02\x01\x01\x12\x03m\x0e\x14\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x03m\x17\x18\nK\n\x04\x04\x05\x02\x02\x12\x03p\x08\x1e\x1a>\x20\
    This\x20field\x20contains\x20the\x20result\x20of\x20executing\x20this\
    \x20invocation.\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04p\x08m\x19\n\x0c\
    \n\x05\x04\x05\x02\x02\x06\x12\x03p\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03p\x11\x19\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03p\x1c\x1d\n\
    \xe2\x02\n\x04\x04\x05\x02\x03\x12\x03w\x08%\x1a\xd4\x02\x20This\x20fiel\
    d\x20contains\x20the\x20ChaincodeID\x20of\x20executing\x20this\x20invoca\
    tion.\x20Endorser\n\x20will\x20set\x20it\x20with\x20the\x20ChaincodeID\
    \x20called\x20by\x20endorser\x20while\x20simulating\x20proposal.\n\x20Co\
    mmitter\x20will\x20validate\x20the\x20version\x20matching\x20with\x20lat\
    est\x20chaincode\x20version.\n\x20Adding\x20ChaincodeID\x20to\x20keep\
    \x20version\x20opens\x20up\x20the\x20possibility\x20of\x20multiple\n\x20\
    ChaincodeAction\x20per\x20transaction.\n\n\r\n\x05\x04\x05\x02\x03\x04\
    \x12\x04w\x08p\x1e\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\x03w\x08\x13\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03w\x14\x20\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03w#$\nn\n\x04\x04\x05\x02\x04\x12\x03{\x08/\x1aa\x20This\
    \x20field\x20contains\x20the\x20token\x20expectation\x20generated\x20by\
    \x20the\x20chaincode\n\x20executing\x20this\x20invocation\n\n\r\n\x05\
    \x04\x05\x02\x04\x04\x12\x04{\x08w%\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\
    \x03{\x08\x18\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03{\x19*\n\x0c\n\x05\
    \x04\x05\x02\x04\x03\x12\x03{-.\nv\n\x02\x04\x06\x12\x06\x80\x01\0\x8a\
    \x01\x01\x1ah\x20A\x20response\x20with\x20a\x20representation\x20similar\
    \x20to\x20an\x20HTTP\x20response\x20that\x20can\n\x20be\x20used\x20withi\
    n\x20another\x20message.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x80\x01\x08\
    \x10\nG\n\x04\x04\x06\x02\0\x12\x04\x83\x01\x08\x19\x1a9\x20A\x20status\
    \x20code\x20that\x20should\x20follow\x20the\x20HTTP\x20status\x20codes.\
    \n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\x83\x01\x08\x80\x01\x12\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\x83\x01\x08\r\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\x83\x01\x0e\x14\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x83\x01\x17\
    \x18\n<\n\x04\x04\x06\x02\x01\x12\x04\x86\x01\x08\x1b\x1a.\x20A\x20messa\
    ge\x20associated\x20with\x20the\x20response\x20code.\n\n\x0f\n\x05\x04\
    \x06\x02\x01\x04\x12\x06\x86\x01\x08\x83\x01\x19\n\r\n\x05\x04\x06\x02\
    \x01\x05\x12\x04\x86\x01\x08\x0e\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\
    \x86\x01\x0f\x16\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x86\x01\x19\x1a\n\
    R\n\x04\x04\x06\x02\x02\x12\x04\x89\x01\x08\x1a\x1aD\x20A\x20payload\x20\
    that\x20can\x20be\x20used\x20to\x20include\x20metadata\x20with\x20this\
    \x20response.\n\n\x0f\n\x05\x04\x06\x02\x02\x04\x12\x06\x89\x01\x08\x86\
    \x01\x1b\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\x89\x01\x08\r\n\r\n\x05\
    \x04\x06\x02\x02\x01\x12\x04\x89\x01\x0e\x15\n\r\n\x05\x04\x06\x02\x02\
    \x03\x12\x04\x89\x01\x18\x19\n\xe9\x03\n\x02\x04\x07\x12\x06\x93\x01\0\
    \x9d\x01\x01\x1a\xda\x03ChaincodeID\x20contains\x20the\x20path\x20as\x20\
    specified\x20by\x20the\x20deploy\x20transaction\nthat\x20created\x20it\
    \x20as\x20well\x20as\x20the\x20hashCode\x20that\x20is\x20generated\x20by\
    \x20the\nsystem\x20for\x20the\x20path.\x20From\x20the\x20user\x20level\
    \x20(ie,\x20CLI,\x20REST\x20API\x20and\x20so\x20on)\ndeploy\x20transacti\
    on\x20is\x20expected\x20to\x20provide\x20the\x20path\x20and\x20other\x20\
    requests\nare\x20expected\x20to\x20provide\x20the\x20hashCode.\x20The\
    \x20other\x20value\x20will\x20be\x20ignored.\nInternally,\x20the\x20stru\
    cture\x20could\x20contain\x20both\x20values.\x20For\x20instance,\x20the\
    \nhashCode\x20will\x20be\x20set\x20when\x20first\x20generated\x20using\
    \x20the\x20path\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x93\x01\x08\x13\n3\n\
    \x04\x04\x07\x02\0\x12\x04\x95\x01\x08\x18\x1a%deploy\x20transaction\x20\
    will\x20use\x20the\x20path\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x95\
    \x01\x08\x93\x01\x15\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x95\x01\x08\x0e\
    \n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x95\x01\x0f\x13\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\x95\x01\x16\x17\nk\n\x04\x04\x07\x02\x01\x12\x04\x99\
    \x01\x08\x18\x1a]all\x20other\x20requests\x20will\x20use\x20the\x20name\
    \x20(really\x20a\x20hashcode)\x20generated\x20by\nthe\x20deploy\x20trans\
    action\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\x99\x01\x08\x95\x01\x18\
    \n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x99\x01\x08\x0e\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\x99\x01\x0f\x13\n\r\n\x05\x04\x07\x02\x01\x03\x12\
    \x04\x99\x01\x16\x17\n;\n\x04\x04\x07\x02\x02\x12\x04\x9c\x01\x08\x1b\
    \x1a-user\x20friendly\x20version\x20name\x20for\x20the\x20chaincode\n\n\
    \x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\x9c\x01\x08\x99\x01\x18\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\x9c\x01\x08\x0e\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\x9c\x01\x0f\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x9c\
    \x01\x19\x1a\nl\n\x02\x04\x08\x12\x06\xa0\x01\0\xa5\x01\x01\x1a^\x20Toke\
    nExpectation\x20represent\x20the\x20belief\x20that\x20someone\x20should\
    \x20achieve\x20in\x20terms\x20of\x20a\x20token\x20action\n\n\x0b\n\x03\
    \x04\x08\x01\x12\x04\xa0\x01\x08\x18\n\x0e\n\x04\x04\x08\x08\0\x12\x06\
    \xa1\x01\x08\xa4\x01\t\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\xa1\x01\x0e\
    \x19\nD\n\x04\x04\x08\x02\0\x12\x04\xa3\x01\x18?\x1a6\x20PlainExpectatio\
    n\x20describes\x20a\x20plain\x20token\x20expectation\n\n\r\n\x05\x04\x08\
    \x02\0\x06\x12\x04\xa3\x01\x18(\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xa3\
    \x01):\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa3\x01=>\nf\n\x02\x04\t\x12\
    \x06\xa8\x01\0\xaf\x01\x01\x1aX\x20PlainExpectation\x20represent\x20the\
    \x20plain\x20expectation\x20where\x20no\x20confidentiality\x20is\x20prov\
    ided.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xa8\x01\x08\x18\n\x0e\n\x04\x04\t\
    \x08\0\x12\x06\xa9\x01\x08\xae\x01\t\n\r\n\x05\x04\t\x08\0\x01\x12\x04\
    \xa9\x01\x0e\x15\nG\n\x04\x04\t\x02\0\x12\x04\xab\x01\x18E\x1a9\x20Impor\
    tExpectation\x20describes\x20an\x20token\x20import\x20expectation\n\n\r\
    \n\x05\x04\t\x02\0\x06\x12\x04\xab\x01\x18-\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xab\x01.@\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xab\x01CD\nJ\n\x04\
    \x04\t\x02\x01\x12\x04\xad\x01\x18G\x1a<\x20TransferExpectation\x20descr\
    ibes\x20a\x20token\x20transfer\x20expectation\n\n\r\n\x05\x04\t\x02\x01\
    \x06\x12\x04\xad\x01\x18-\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xad\x01.B\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xad\x01EF\ne\n\x02\x04\n\x12\x06\
    \xb3\x01\0\xb6\x01\x01\x1aW\x20PlainTokenExpectation\x20represents\x20th\
    e\x20expecation\x20that\n\x20certain\x20outputs\x20will\x20be\x20matched\
    \n\n\x0b\n\x03\x04\n\x01\x12\x04\xb3\x01\x08\x1d\n5\n\x04\x04\n\x02\0\
    \x12\x04\xb5\x01\x08)\x1a'\x20Outputs\x20contains\x20the\x20expected\x20\
    outputs\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x06\x12\x04\xb5\x01\x11\x1c\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xb5\x01\x1d$\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb5\x01'(\nf\n\x02\
    \x04\x0b\x12\x06\xb9\x01\0\xc3\x01\x01\x1aX\x20A\x20PlainOutput\x20is\
    \x20the\x20result\x20of\x20import\x20and\x20transfer\x20transactions\x20\
    using\x20plaintext\x20tokens\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb9\x01\
    \x08\x13\nM\n\x04\x04\x0b\x02\0\x12\x04\xbc\x01\x08\x18\x1a?\x20The\x20o\
    wner\x20is\x20the\x20serialization\x20of\x20a\x20SerializedIdentity\x20s\
    truct\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xbc\x01\x08\xb9\x01\x15\n\
    \r\n\x05\x04\x0b\x02\0\x05\x12\x04\xbc\x01\x08\r\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xbc\x01\x0e\x13\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xbc\x01\
    \x16\x17\n\x1e\n\x04\x04\x0b\x02\x01\x12\x04\xbf\x01\x08\x18\x1a\x10\x20\
    The\x20token\x20type\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\xbf\x01\
    \x08\xbc\x01\x18\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xbf\x01\x08\x0e\n\
    \r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xbf\x01\x0f\x13\n\r\n\x05\x04\x0b\
    \x02\x01\x03\x12\x04\xbf\x01\x16\x17\n&\n\x04\x04\x0b\x02\x02\x12\x04\
    \xc2\x01\x08\x1c\x1a\x18\x20The\x20quantity\x20of\x20tokens\n\n\x0f\n\
    \x05\x04\x0b\x02\x02\x04\x12\x06\xc2\x01\x08\xbf\x01\x18\n\r\n\x05\x04\
    \x0b\x02\x02\x05\x12\x04\xc2\x01\x08\x0e\n\r\n\x05\x04\x0b\x02\x02\x01\
    \x12\x04\xc2\x01\x0f\x17\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xc2\x01\
    \x1a\x1b\n{\n\x02\x04\x0c\x12\x06\xc7\x01\0\xcc\x01\x01\x1amChaincodeEve\
    nt\x20is\x20used\x20for\x20events\x20and\x20registrations\x20that\x20are\
    \x20specific\x20to\x20chaincode\nstring\x20type\x20-\x20\"chaincode\"\n\
    \n\x0b\n\x03\x04\x0c\x01\x12\x04\xc7\x01\x08\x16\n\x0c\n\x04\x04\x0c\x02\
    \0\x12\x04\xc8\x01\x08\x20\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xc8\x01\
    \x08\xc7\x01\x18\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xc8\x01\x08\x0e\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\xc8\x01\x0f\x1b\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xc8\x01\x1e\x1f\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xc9\x01\
    \x08\x19\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xc9\x01\x08\xc8\x01\x20\
    \n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xc9\x01\x08\x0e\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xc9\x01\x0f\x14\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\xc9\x01\x17\x18\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xca\x01\x08\x1e\
    \n\x0f\n\x05\x04\x0c\x02\x02\x04\x12\x06\xca\x01\x08\xc9\x01\x19\n\r\n\
    \x05\x04\x0c\x02\x02\x05\x12\x04\xca\x01\x08\x0e\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\xca\x01\x0f\x19\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\
    \xca\x01\x1c\x1d\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xcb\x01\x08\x1a\n\
    \x0f\n\x05\x04\x0c\x02\x03\x04\x12\x06\xcb\x01\x08\xca\x01\x1e\n\r\n\x05\
    \x04\x0c\x02\x03\x05\x12\x04\xcb\x01\x08\r\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\xcb\x01\x0e\x15\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xcb\x01\
    \x18\x19\n|\n\x02\x04\r\x12\x06\xd1\x01\0\xd7\x01\x01\x1an\x20This\x20st\
    ruct\x20represents\x20an\x20Identity\n\x20(with\x20its\x20MSP\x20identif\
    ier)\x20to\x20be\x20used\n\x20to\x20serialize\x20it\x20and\x20deserializ\
    e\x20it\n\n\x0b\n\x03\x04\r\x01\x12\x04\xd1\x01\x08\x1a\nL\n\x04\x04\r\
    \x02\0\x12\x04\xd3\x01\x04\x15\x1a>\x20The\x20identifier\x20of\x20the\
    \x20associated\x20membership\x20service\x20provider\n\n\x0f\n\x05\x04\r\
    \x02\0\x04\x12\x06\xd3\x01\x04\xd1\x01\x1c\n\r\n\x05\x04\r\x02\0\x05\x12\
    \x04\xd3\x01\x04\n\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xd3\x01\x0b\x10\n\r\
    \n\x05\x04\r\x02\0\x03\x12\x04\xd3\x01\x13\x14\nJ\n\x04\x04\r\x02\x01\
    \x12\x04\xd6\x01\x04\x17\x1a<\x20the\x20Identity,\x20serialized\x20accor\
    ding\x20to\x20the\x20rules\x20of\x20its\x20MPS\n\n\x0f\n\x05\x04\r\x02\
    \x01\x04\x12\x06\xd6\x01\x04\xd3\x01\x15\n\r\n\x05\x04\r\x02\x01\x05\x12\
    \x04\xd6\x01\x04\t\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xd6\x01\n\x12\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xd6\x01\x15\x16b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
